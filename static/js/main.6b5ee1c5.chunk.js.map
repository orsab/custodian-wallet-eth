{"version":3,"sources":["components/NoWalletDetected.js","components/NetworkErrorMessage.js","components/ConnectWallet.js","components/Loading.js","components/Transfer.js","components/TransactionErrorMessage.js","components/WaitingForTransactionMessage.js","components/NoTokensMessage.js","components/Dapp.js","components/CustodianDApp.js","index.js"],"names":["NoWalletDetected","className","href","target","rel","NetworkErrorMessage","message","dismiss","role","type","data-dismiss","aria-label","onClick","aria-hidden","ConnectWallet","connectWallet","networkError","Loading","style","position","zIndex","top","left","width","height","background","marginLeft","marginTop","textAlign","Transfer","transferTokens","tokenSymbol","onSubmit","event","preventDefault","formData","FormData","to","get","amount","step","name","placeholder","required","value","TransactionErrorMessage","substring","WaitingForTransactionMessage","txHash","NoTokensMessage","selectedAddress","React","Component","initialState","tokenData","undefined","balance","txBeingSent","transactionError","tokens","PUNK","MUNK","token","tokenAddress","MUNKAddress","Token","PUNKAddress","CustodianDApp","useState","state","setState","_provider","setProvider","_pollDataInterval","setPollDataInterval","id","address","input","setInput","custodians","setCustodians","transferState","setTransferState","_dismissNetworkError","useCallback","_initialize","userAddress","_custodians","window","localStorage","getItem","JSON","parse","provider","ethers","providers","Web3Provider","ethereum","useEffect","setInterval","_updateBalance","_stopPollingData","clearInterval","a","rawData","MUNKToken","Contract","MUNKArtifact","abi","getSigner","PUNKToken","PUNKArtifact","Promise","all","balanceOf","munkCount","punkCount","custodian","contractAddress","CustodianArtifact","balances","map","b","toString","find","t","console","log","setItem","stringify","_resetState","_checkNetwork","process","networkVersion","_connectWallet","request","method","on","newAddress","addCustodian","e","newCustodian","factory","ContractFactory","bytecode","deploy","contract","deployed","push","onInputChange","field","persist","onWithdraw","custodianContract","withdraw","setTransfer","fromToken","onSendTransaction","transfer","toAddress","key","onChange","border","c","vlaue","custodianWallet","importToken","_c","filtered","filter","colSpan","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6b5ee1c5.chunk.js","sourcesContent":["import React from \"react\";\n\nexport function NoWalletDetected() {\n  return (\n    <div className=\"container\">\n      <div className=\"row justify-content-md-center\">\n        <div className=\"col-6 p-4 text-center\">\n          <p>\n            No Ethereum wallet was detected. <br />\n            Please install{\" \"}\n            <a\n              href=\"http://metamask.io\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              MetaMask\n            </a>\n            .\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function NetworkErrorMessage({ message, dismiss }) {\n  return (\n    <div className=\"alert alert-danger\" role=\"alert\">\n      {message}\n      <button\n        type=\"button\"\n        className=\"close\"\n        data-dismiss=\"alert\"\n        aria-label=\"Close\"\n        onClick={dismiss}\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n  );\n}\n","import React from \"react\";\n\nimport { NetworkErrorMessage } from \"./NetworkErrorMessage\";\n\nexport function ConnectWallet({ connectWallet, networkError, dismiss }) {\n  return (\n    <div className=\"container\">\n      <div className=\"row justify-content-md-center\">\n        <div className=\"col-12 text-center\">\n          {/* Metamask network should be set to Localhost:8545. */}\n          {networkError && (\n            <NetworkErrorMessage \n              message={networkError} \n              dismiss={dismiss} \n            />\n          )}\n        </div>\n        <div className=\"col-6 p-4 text-center\">\n          <p>Please connect to your wallet.</p>\n          <button\n            className=\"btn btn-warning\"\n            type=\"button\"\n            onClick={connectWallet}\n          >\n            Connect Wallet\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function Loading() {\n  return (\n    <div\n      style={{\n        position: \"fixed\",\n        zIndex: 2,\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        background: \"rgba(255, 255, 255, 0.5)\",\n      }}\n    >\n      <div\n        style={{\n          position: \"absolute\",\n          zIndex: 3,\n          top: \"50%\",\n          left: \"50%\",\n          width: \"100px\",\n          height: \"50px\",\n          marginLeft: \"-50px\",\n          marginTop: \" -25px\",\n          textAlign: \"center\",\n        }}\n      >\n        <div className=\"spinner-border\" role=\"status\">\n          <span className=\"sr-only\">Loading...</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function Transfer({ transferTokens, tokenSymbol }) {\n  return (\n    <div>\n      <h4>Transfer</h4>\n      <form\n        onSubmit={(event) => {\n          // This function just calls the transferTokens callback with the\n          // form's data.\n          event.preventDefault();\n\n          const formData = new FormData(event.target);\n          const to = formData.get(\"to\");\n          const amount = formData.get(\"amount\");\n\n          if (to && amount) {\n            transferTokens(to, amount);\n          }\n        }}\n      >\n        <div className=\"form-group\">\n          <label>Amount of {tokenSymbol}</label>\n          <input\n            className=\"form-control\"\n            type=\"number\"\n            step=\"1\"\n            name=\"amount\"\n            placeholder=\"1\"\n            required\n          />\n        </div>\n        <div className=\"form-group\">\n          <label>Recipient address</label>\n          <input className=\"form-control\" type=\"text\" name=\"to\" required />\n        </div>\n        <div className=\"form-group\">\n          <input className=\"btn btn-primary\" type=\"submit\" value=\"Transfer\" />\n        </div>\n      </form>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function TransactionErrorMessage({ message, dismiss }) {\n  return (\n    <div className=\"alert alert-danger\" role=\"alert\">\n      Error sending transaction: {message.substring(0, 100)}\n      <button\n        type=\"button\"\n        className=\"close\"\n        data-dismiss=\"alert\"\n        aria-label=\"Close\"\n        onClick={dismiss}\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function WaitingForTransactionMessage({ txHash }) {\n  return (\n    <div className=\"alert alert-info\" role=\"alert\">\n      Waiting for transaction <strong>{txHash}</strong> to be mined\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function NoTokensMessage({ selectedAddress }) {\n  return (\n    <>\n      <p>You don't have tokens to transfer</p>\n      <p>\n        To get some tokens, open a terminal in the root of the repository and run: \n        <br />\n        <br />\n        <code>npx hardhat --network localhost faucet {selectedAddress}</code>\n      </p>\n    </>\n  );\n}\n","import React from \"react\";\n\n// We'll use ethers to interact with the Ethereum network and our contract\nimport { ethers } from \"ethers\";\n\n// We import the contract's artifacts and address here, as we are going to be\n// using them with ethers\nimport TokenArtifact from \"../contracts/Token.json\";\nimport contractAddress from \"../contracts/contract-address.json\";\n\n// All the logic of this dapp is contained in the Dapp component.\n// These other components are just presentational ones: they don't have any\n// logic. They just render HTML.\nimport { NoWalletDetected } from \"./NoWalletDetected\";\nimport { ConnectWallet } from \"./ConnectWallet\";\nimport { Loading } from \"./Loading\";\nimport { Transfer } from \"./Transfer\";\nimport { TransactionErrorMessage } from \"./TransactionErrorMessage\";\nimport { WaitingForTransactionMessage } from \"./WaitingForTransactionMessage\";\nimport { NoTokensMessage } from \"./NoTokensMessage\";\n\n// This is the Hardhat Network id, you might change it in the hardhat.config.js.\n// If you are using MetaMask, be sure to change the Network id to 1337.\n// Here's a list of network ids https://docs.metamask.io/guide/ethereum-provider.html#properties\n// to use when deploying to other networks.\n// const HARDHAT_NETWORK_ID = '1337';\nconst HARDHAT_NETWORK_ID = '31337';\n\n// This is an error code that indicates that the user canceled a transaction\nconst ERROR_CODE_TX_REJECTED_BY_USER = 4001;\n\n// This component is in charge of doing these things:\n//   1. It connects to the user's wallet\n//   2. Initializes ethers and the Token contract\n//   3. Polls the user balance to keep it updated.\n//   4. Transfers tokens by sending transactions\n//   5. Renders the whole application\n//\n// Note that (3) and (4) are specific of this sample application, but they show\n// you how to keep your Dapp and contract's state in sync,  and how to send a\n// transaction.\nexport class Dapp extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // We store multiple things in Dapp's state.\n    // You don't need to follow this pattern, but it's an useful example.\n    this.initialState = {\n      // The info of the token (i.e. It's Name and symbol)\n      tokenData: undefined,\n      // The user's address and balance\n      selectedAddress: undefined,\n      balance: undefined,\n      // The ID about transactions being sent, and any possible error with them\n      txBeingSent: undefined,\n      transactionError: undefined,\n      networkError: undefined,\n    };\n\n    this.state = this.initialState;\n  }\n\n  render() {\n    // Ethereum wallets inject the window.ethereum object. If it hasn't been\n    // injected, we instruct the user to install MetaMask.\n    if (window.ethereum === undefined) {\n      return <NoWalletDetected />;\n    }\n\n    // The next thing we need to do, is to ask the user to connect their wallet.\n    // When the wallet gets connected, we are going to save the users's address\n    // in the component's state. So, if it hasn't been saved yet, we have\n    // to show the ConnectWallet component.\n    //\n    // Note that we pass it a callback that is going to be called when the user\n    // clicks a button. This callback just calls the _connectWallet method.\n    if (!this.state.selectedAddress) {\n      return (\n        <ConnectWallet \n          connectWallet={() => this._connectWallet()} \n          networkError={this.state.networkError}\n          dismiss={() => this._dismissNetworkError()}\n        />\n      );\n    }\n\n    // If the token data or the user's balance hasn't loaded yet, we show\n    // a loading component.\n    if (!this.state.tokenData || !this.state.balance) {\n      return <Loading />;\n    }\n\n    // If everything is loaded, we render the application.\n    return (\n      <div className=\"container p-4\">\n        <div className=\"row\">\n          <div className=\"col-12\">\n            <h1>\n              {this.state.tokenData.name} ({this.state.tokenData.symbol})\n            </h1>\n            <p>\n              Welcome <b>{this.state.selectedAddress}</b>, you have{\" \"}\n              <b>\n                {this.state.balance.toString()} {this.state.tokenData.symbol}\n              </b>\n              .\n            </p>\n          </div>\n        </div>\n\n        <hr />\n\n        <div className=\"row\">\n          <div className=\"col-12\">\n            {/* \n              Sending a transaction isn't an immediate action. You have to wait\n              for it to be mined.\n              If we are waiting for one, we show a message here.\n            */}\n            {this.state.txBeingSent && (\n              <WaitingForTransactionMessage txHash={this.state.txBeingSent} />\n            )}\n\n            {/* \n              Sending a transaction can fail in multiple ways. \n              If that happened, we show a message here.\n            */}\n            {this.state.transactionError && (\n              <TransactionErrorMessage\n                message={this._getRpcErrorMessage(this.state.transactionError)}\n                dismiss={() => this._dismissTransactionError()}\n              />\n            )}\n          </div>\n        </div>\n\n        <div className=\"row\">\n          <div className=\"col-12\">\n            {/*\n              If the user has no tokens, we don't show the Transfer form\n            */}\n            {this.state.balance.eq(0) && (\n              <NoTokensMessage selectedAddress={this.state.selectedAddress} />\n            )}\n\n            {/*\n              This component displays a form that the user can use to send a \n              transaction and transfer some tokens.\n              The component doesn't have logic, it just calls the transferTokens\n              callback.\n            */}\n            {this.state.balance.gt(0) && (\n              <Transfer\n                transferTokens={(to, amount) =>\n                  this._transferTokens(to, amount)\n                }\n                tokenSymbol={this.state.tokenData.symbol}\n              />\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  componentWillUnmount() {\n    // We poll the user's balance, so we have to stop doing that when Dapp\n    // gets unmounted\n    this._stopPollingData();\n  }\n\n  async _connectWallet() {\n    // This method is run when the user clicks the Connect. It connects the\n    // dapp to the user's wallet, and initializes it.\n\n    // To connect to the user's wallet, we have to run this method.\n    // It returns a promise that will resolve to the user's address.\n    const [selectedAddress] = await window.ethereum.request({ method: 'eth_requestAccounts' });\n\n    // Once we have the address, we can initialize the application.\n\n    // First we check the network\n    if (!this._checkNetwork()) {\n      return;\n    }\n\n    this._initialize(selectedAddress);\n\n    // We reinitialize it whenever the user changes their account.\n    window.ethereum.on(\"accountsChanged\", ([newAddress]) => {\n      this._stopPollingData();\n      // `accountsChanged` event can be triggered with an undefined newAddress.\n      // This happens when the user removes the Dapp from the \"Connected\n      // list of sites allowed access to your addresses\" (Metamask > Settings > Connections)\n      // To avoid errors, we reset the dapp state \n      if (newAddress === undefined) {\n        return this._resetState();\n      }\n      \n      this._initialize(newAddress);\n    });\n    \n    // We reset the dapp state if the network is changed\n    window.ethereum.on(\"chainChanged\", ([networkId]) => {\n      this._stopPollingData();\n      this._resetState();\n    });\n  }\n\n  _initialize(userAddress) {\n    // This method initializes the dapp\n\n    // We first store the user's address in the component's state\n    this.setState({\n      selectedAddress: userAddress,\n    });\n\n    // Then, we initialize ethers, fetch the token's data, and start polling\n    // for the user's balance.\n\n    // Fetching the token data and the user's balance are specific to this\n    // sample project, but you can reuse the same initialization pattern.\n    this._initializeEthers();\n    this._getTokenData();\n    this._startPollingData();\n  }\n\n  async _initializeEthers() {\n    // We first initialize ethers by creating a provider using window.ethereum\n    this._provider = new ethers.providers.Web3Provider(window.ethereum);\n\n    // Then, we initialize the contract using that provider and the token's\n    // artifact. You can do this same thing with your contracts.\n    this._token = new ethers.Contract(\n      contractAddress.Token,\n      TokenArtifact.abi,\n      this._provider.getSigner(0)\n    );\n  }\n\n  // The next two methods are needed to start and stop polling data. While\n  // the data being polled here is specific to this example, you can use this\n  // pattern to read any data from your contracts.\n  //\n  // Note that if you don't need it to update in near real time, you probably\n  // don't need to poll it. If that's the case, you can just fetch it when you\n  // initialize the app, as we do with the token data.\n  _startPollingData() {\n    this._pollDataInterval = setInterval(() => this._updateBalance(), 1000);\n\n    // We run it once immediately so we don't have to wait for it\n    this._updateBalance();\n  }\n\n  _stopPollingData() {\n    clearInterval(this._pollDataInterval);\n    this._pollDataInterval = undefined;\n  }\n\n  // The next two methods just read from the contract and store the results\n  // in the component state.\n  async _getTokenData() {\n    const name = await this._token.name();\n    const symbol = await this._token.symbol();\n\n    this.setState({ tokenData: { name, symbol } });\n  }\n\n  async _updateBalance() {\n    const balance = await this._token.balanceOf(this.state.selectedAddress);\n    this.setState({ balance });\n  }\n\n  // This method sends an ethereum transaction to transfer tokens.\n  // While this action is specific to this application, it illustrates how to\n  // send a transaction.\n  async _transferTokens(to, amount) {\n    // Sending a transaction is a complex operation:\n    //   - The user can reject it\n    //   - It can fail before reaching the ethereum network (i.e. if the user\n    //     doesn't have ETH for paying for the tx's gas)\n    //   - It has to be mined, so it isn't immediately confirmed.\n    //     Note that some testing networks, like Hardhat Network, do mine\n    //     transactions immediately, but your dapp should be prepared for\n    //     other networks.\n    //   - It can fail once mined.\n    //\n    // This method handles all of those things, so keep reading to learn how to\n    // do it.\n\n    try {\n      // If a transaction fails, we save that error in the component's state.\n      // We only save one such error, so before sending a second transaction, we\n      // clear it.\n      this._dismissTransactionError();\n\n      // We send the transaction, and save its hash in the Dapp's state. This\n      // way we can indicate that we are waiting for it to be mined.\n      const tx = await this._token.transfer(to, amount);\n      this.setState({ txBeingSent: tx.hash });\n\n      // We use .wait() to wait for the transaction to be mined. This method\n      // returns the transaction's receipt.\n      const receipt = await tx.wait();\n\n      // The receipt, contains a status flag, which is 0 to indicate an error.\n      if (receipt.status === 0) {\n        // We can't know the exact error that made the transaction fail when it\n        // was mined, so we throw this generic one.\n        throw new Error(\"Transaction failed\");\n      }\n\n      // If we got here, the transaction was successful, so you may want to\n      // update your state. Here, we update the user's balance.\n      await this._updateBalance();\n    } catch (error) {\n      // We check the error code to see if this error was produced because the\n      // user rejected a tx. If that's the case, we do nothing.\n      if (error.code === ERROR_CODE_TX_REJECTED_BY_USER) {\n        return;\n      }\n\n      // Other errors are logged and stored in the Dapp's state. This is used to\n      // show them to the user, and for debugging.\n      console.error(error);\n      this.setState({ transactionError: error });\n    } finally {\n      // If we leave the try/catch, we aren't sending a tx anymore, so we clear\n      // this part of the state.\n      this.setState({ txBeingSent: undefined });\n    }\n  }\n\n  // This method just clears part of the state.\n  _dismissTransactionError() {\n    this.setState({ transactionError: undefined });\n  }\n\n  // This method just clears part of the state.\n  _dismissNetworkError() {\n    this.setState({ networkError: undefined });\n  }\n\n  // This is an utility method that turns an RPC error into a human readable\n  // message.\n  _getRpcErrorMessage(error) {\n    if (error.data) {\n      return error.data.message;\n    }\n\n    return error.message;\n  }\n\n  // This method resets the state\n  _resetState() {\n    this.setState(this.initialState);\n  }\n\n  // This method checks if Metamask selected network is Localhost:8545 \n  _checkNetwork() {\n    if (window.ethereum.networkVersion === HARDHAT_NETWORK_ID) {\n      return true;\n    }\n\n    this.setState({ \n      networkError: 'Please connect Metamask to Localhost:8545'\n    });\n\n    return false;\n  }\n}\n","import React, { useCallback, useEffect, useState } from \"react\";\n\n// We'll use ethers to interact with the Ethereum network and our contract\nimport { ethers, ContractFactory } from \"ethers\";\n\n// We import the contract's artifacts and address here, as we are going to be\n// using them with ethers\nimport MUNKArtifact from \"../contracts/MUNK.json\";\nimport PUNKArtifact from \"../contracts/PUNK.json\";\nimport MUNKAddress from \"../contracts/MUNK-address.json\";\nimport PUNKAddress from \"../contracts/PUNK-address.json\";\nimport CustodianArtifact from \"../contracts/CustodianSC.json\";\n\n// All the logic of this dapp is contained in the Dapp component.\n// These other components are just presentational ones: they don't have any\n// logic. They just render HTML.\nimport { NoWalletDetected } from \"./NoWalletDetected\";\nimport { ConnectWallet } from \"./ConnectWallet\";\nimport { Loading } from \"./Loading\";\nimport { Transfer } from \"./Transfer\";\nimport { TransactionErrorMessage } from \"./TransactionErrorMessage\";\nimport { WaitingForTransactionMessage } from \"./WaitingForTransactionMessage\";\nimport { NoTokensMessage } from \"./NoTokensMessage\";\n\n// This is the Hardhat Network id, you might change it in the hardhat.config.js.\n// If you are using MetaMask, be sure to change the Network id to 1337.\n// Here's a list of network ids https://docs.metamask.io/guide/ethereum-provider.html#properties\n// to use when deploying to other networks.\n// const HARDHAT_NETWORK_ID = '1337';\nconst HARDHAT_NETWORK_ID = \"31337\";\n\n// This is an error code that indicates that the user canceled a transaction\nconst ERROR_CODE_TX_REJECTED_BY_USER = 4001;\n\n// This component is in charge of doing these things:\n//   1. It connects to the user's wallet\n//   2. Initializes ethers and the Token contract\n//   3. Polls the user balance to keep it updated.\n//   4. Transfers tokens by sending transactions\n//   5. Renders the whole application\n//\n// Note that (3) and (4) are specific of this sample application, but they show\n// you how to keep your Dapp and contract's state in sync,  and how to send a\n// transaction.\nconst initialState = {\n  tokenData: undefined,\n  selectedAddress: undefined,\n  balance: undefined,\n  txBeingSent: undefined,\n  transactionError: undefined,\n  networkError: undefined,\n  tokens:[],\n  PUNK:0,\n  MUNK:0,\n};\n\nconst tokens = [{token:'MUNK',tokenAddress:MUNKAddress.Token},{token:'PUNK',tokenAddress:PUNKAddress.Token}]\n\nconst CustodianDApp = () => {\n  const [state, setState] = useState(initialState);\n  const [_provider, setProvider] = useState(null);\n  const [_pollDataInterval, setPollDataInterval] = useState(null);\n  const [input, setInput] = useState({ id: \"\", address: \"\",token:\"\" });\n  const [custodians, setCustodians] = useState([]);\n  const [transferState, setTransferState] = useState({});\n\n  const _dismissNetworkError = useCallback(() => {\n    setState((state) => ({ ...state, networkError: undefined }));\n  }, []);\n\n  const _initialize = (userAddress) => {\n    const _custodians = window.localStorage.getItem(\"data\");\n    setCustodians(_custodians ? JSON.parse(_custodians) : []);\n\n    setState((state) => ({ ...state, selectedAddress: userAddress }));\n\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    setProvider(provider);\n\n    // // Then, we initialize the contract using that provider and the token's\n    // // artifact. You can do this same thing with your contracts.\n    // const MUNKToken = new ethers.Contract(\n    //   MUNKAddress.Token,\n    //   MUNKArtifact.abi,\n    //   provider.getSigner(0)\n    // );\n    // const PUNKToken = new ethers.Contract(\n    //   PUNKAddress.Token,\n    //   PUNKArtifact.abi,\n    //   provider.getSigner(0)\n    // );\n\n  };\n\n  useEffect(() => {\n    if(!_provider){\n      return\n    }\n    setPollDataInterval(\n      setInterval(() => {\n        _updateBalance();\n      }, 1000)\n    );\n  }, [_provider]);\n\n  const _stopPollingData = useCallback(() => {\n    clearInterval(_pollDataInterval);\n    _pollDataInterval = undefined;\n  }, [_pollDataInterval]);\n\n  const _updateBalance = async () => {\n    const rawData = window.localStorage.getItem(\"data\")\n    const _custodians = rawData ? JSON.parse(rawData) : [];\n\n\n\n    const MUNKToken = new ethers.Contract(\n      MUNKAddress.Token,\n      MUNKArtifact.abi,\n      _provider.getSigner(0)\n    )\n    const PUNKToken = new ethers.Contract(\n      PUNKAddress.Token,\n      PUNKArtifact.abi,\n      _provider.getSigner(0)\n    )\n\n    const [munkCount, punkCount] = await Promise.all([MUNKToken.balanceOf(state.selectedAddress),PUNKToken.balanceOf(state.selectedAddress)])\n    setState({\n      ...state,\n      MUNK:munkCount,\n      PUNK:punkCount\n    })\n\n    for (const custodian of _custodians) {\n      if (!custodian.contractAddress) {\n        continue;\n      }\n\n      const Token = new ethers.Contract(\n        custodian.contractAddress,\n        CustodianArtifact.abi,\n        _provider.getSigner(0)\n      )\n\n      // await Token.importToken(custodian.id, state.tokens[0].address);\n      const balances = await Token.balanceOf(custodian.id);\n      \n      custodian.balances = balances.map(b => ({\n        balance: b.balance.toString(),\n        token: tokens.find(t => t.tokenAddress == b.tokenAddress)?.token || ''\n      }))\n\n      console.log(custodian.balances)\n    }\n    setCustodians(_custodians);\n    window.localStorage.setItem(\"data\", JSON.stringify(_custodians));\n  }\n\n  const _resetState = () => {\n    setState(initialState);\n  };\n\n  // This method checks if Metamask selected network is Localhost:8545\n  const _checkNetwork = useCallback(() => {\n    console.log(process.env)\n    if (window.ethereum.networkVersion === process.env.REACT_APP_HARDHAT_NETWORK_ID) {\n      return true;\n    }\n\n    setState({\n      ...state,\n      networkError: \"Please connect Metamask to Ropsten\",\n    });\n\n    return false;\n  }, []);\n\n  const _connectWallet = useCallback(async () => {\n    const [selectedAddress] = await window.ethereum.request({\n      method: \"eth_requestAccounts\",\n    });\n    if (!_checkNetwork()) {\n      return;\n    }\n\n    _initialize(selectedAddress);\n\n    window.ethereum.on(\"accountsChanged\", ([newAddress]) => {\n      _stopPollingData();\n      if (newAddress === undefined) {\n        return _resetState();\n      }\n\n      _initialize(newAddress);\n    });\n\n    window.ethereum.on(\"chainChanged\", ([networkId]) => {\n      _stopPollingData();\n      _resetState();\n    });\n  }, []);\n\n  const addCustodian = async (e) => {\n    const newCustodian = {\n      id: input.id,\n      address: input.address,\n      contractAddress: \"\",\n      balance: [],\n    };\n    const factory = new ContractFactory(\n      CustodianArtifact.abi,\n      CustodianArtifact.bytecode,\n      _provider.getSigner(0)\n    );\n    const contract = await factory.deploy(\n      newCustodian.id,\n      newCustodian.address\n    );\n    await contract.deployed();\n    newCustodian.contractAddress = contract.address;\n\n    custodians.push(newCustodian);\n    setCustodians(custodians);\n    window.localStorage.setItem(\"data\", JSON.stringify(custodians));\n  };\n  const deleteCustodian = _c => (e) => {\n    const filtered = custodians.filter(c => c.id !== _c.id)\n    window.localStorage.setItem(\"data\", JSON.stringify(filtered));\n    setCustodians(filtered)\n  }\n  const resetTable = (e) => {\n    setCustodians([]);\n    window.localStorage.setItem(\"data\", JSON.stringify([]));\n  };\n\n  const onInputChange = (field) => (e) => {\n    e.persist();\n\n    setInput((state) => ({ ...state, [field]: e.target.value }));\n  };\n  const onSelectToken = custodian => async (e) => {\n    if(!input.token){\n      return\n    }\n    const custodianWallet = new ethers.Contract(\n      custodian.contractAddress,\n      CustodianArtifact.abi,\n      _provider.getSigner(0)\n    );\n\n    await custodianWallet.importToken(custodian.id, input.token)\n  };\n\n\n  const onWithdraw = (custodian) => async e => {\n    const custodianContract = new ethers.Contract(\n      custodian.contractAddress,\n      CustodianArtifact.abi,\n      _provider.getSigner(0)\n    )\n\n    await custodianContract.withdraw(custodian.id)\n  }\n\n  const setTransfer = (fromToken, field) => e => {\n    setTransferState({...transferState, fromToken, [field]:e.target.value})\n  }\n\n  const onSendTransaction = async () => {\n    const token = new ethers.Contract(\n      transferState.fromToken,\n      MUNKArtifact.abi,\n      _provider.getSigner(0)\n    )\n\n    await token.transfer(transferState.toAddress, transferState.amount)\n  }\n\n  if (window.ethereum === undefined) {\n    return <NoWalletDetected />;\n  }\n\n  if (!state.selectedAddress) {\n    return (\n      <ConnectWallet\n        connectWallet={_connectWallet}\n        networkError={state.networkError}\n        dismiss={_dismissNetworkError}\n      />\n    );\n  }\n  if (!custodians) {\n    return <Loading />;\n  }\n\n  return (\n    <div className=\"container p-4\">\n      <div className=\"row\">\n        <div className=\"col-12\">\n          <h1>Custodian wallet Demo Page</h1>\n          <p>\n            connected as <b>{state.selectedAddress}</b> Balance: <b>MUNK:{state.MUNK.toString()}</b> <b>PUNK:{state.PUNK.toString()}</b>\n          </p>\n          {tokens.map((t,key) => (\n            <p key={key}>\n              <div className=\"row\">\n                <b>\n                  {t.token}: {t.tokenAddress}\n                </b>\n                <div className=\"col-2\">\n                <input className=\"form-control\" placeholder=\"Send amount\" value={transferState.amount} type=\"number\" onChange={setTransfer(t.tokenAddress, 'amount')} /> </div>\n                <div className=\"col-2\">\n                <input className=\"form-control\" placeholder=\"Send to address\" value={transferState.toAddress} onChange={setTransfer(t.tokenAddress, 'toAddress')} />\n                </div>\n                <div className=\"col-2\">\n                <button className=\"btn btn-primary\" onClick={onSendTransaction}>Send</button>\n                </div>\n              </div>\n            </p>\n          ))}\n        </div>\n      </div>\n\n      <hr />\n\n      <div className=\"row\">\n        <div className=\"col-12\">\n          <div className=\"form-group\">\n            <label>\n              Customer id:{\" \"}\n              <input\n                type=\"text\"\n                className=\"form-control\"\n                value={input.id}\n                onChange={onInputChange(\"id\")}\n              />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <label>\n              Customer address:{\" \"}\n              <input\n                type=\"text\"\n                className=\"form-control\"\n                value={input.address}\n                onChange={onInputChange(\"address\")}\n              />\n            </label>\n          </div>\n          <div className=\"form-group\">\n            <button onClick={addCustodian} className=\"btn btn-primary\">\n              Create\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"row\">\n        <div className=\"col-12\">Custodians:</div>\n\n        <table style={{ width: \"100%\" }} border=\"1\">\n          <thead>\n            <tr>\n              <th>id</th>\n              <th>customer address</th>\n              <th>contract address</th>\n              <th>balance</th>\n              <th>import token</th>\n              <th></th>\n              <th></th>\n            </tr>\n          </thead>\n          <tbody>\n            {custodians.map((c, key) => {\n              return (\n                <tr key={key}>\n                  <td>{c.id}</td>\n                  <td>{c.address}</td>\n                  <td>{c.contractAddress}</td>\n                  <td>{c.balances && c.balances.map((b,key) => <span key={key}>{b.balance}{b.token},</span>)}</td>\n                  <td>\n                    <select value={input.token} onChange={e => setInput({...input,token:e.target.value})}>\n                      <option vlaue=\"\"></option>\n                      {tokens.map(t => <option value={t.tokenAddress}>{t.token}</option>)}\n                    </select>\n                    <button onClick={onSelectToken(c)} className=\"btn btn-info\">Import</button>\n                  </td>\n                  <td>\n                    <button className=\"btn btn-info\" onClick={onWithdraw(c)}>Withdraw</button>\n                  </td>\n                  <td>\n                    <button className=\"btn btn-danger\" onClick={deleteCustodian(c)}>Delete</button>\n                  </td>\n                </tr>\n              );\n            })}\n            <tr>\n              <td colSpan={6}>\n                <button className=\"btn btn-danger\" onClick={resetTable}>\n                  Reset\n                </button>\n              </td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n};\n\nexport default CustodianDApp;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Dapp } from \"./components/Dapp\";\n\n// We import bootstrap here, but you can remove if you want\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport CustodianDApp from \"./components/CustodianDApp\";\n\n// This is the entry point of your application, but it just renders the Dapp\n// react component. All of the logic is contained in it.\n\nReactDOM.render(\n  <React.StrictMode>\n    <CustodianDApp />\n    {/* <Dapp /> */}\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}