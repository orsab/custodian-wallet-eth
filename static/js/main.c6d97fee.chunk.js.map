{"version":3,"sources":["components/NoWalletDetected.js","components/NetworkErrorMessage.js","components/ConnectWallet.js","components/Loading.js","components/Transfer.js","components/TransactionErrorMessage.js","components/WaitingForTransactionMessage.js","components/NoTokensMessage.js","components/Dapp.js","components/CustodianDApp.js","index.js"],"names":["NoWalletDetected","className","href","target","rel","NetworkErrorMessage","message","dismiss","role","type","data-dismiss","aria-label","onClick","aria-hidden","ConnectWallet","connectWallet","networkError","Loading","style","position","zIndex","top","left","width","height","background","marginLeft","marginTop","textAlign","Transfer","transferTokens","tokenSymbol","onSubmit","event","preventDefault","formData","FormData","to","get","amount","step","name","placeholder","required","value","TransactionErrorMessage","substring","WaitingForTransactionMessage","txHash","NoTokensMessage","selectedAddress","React","Component","_pollDataInterval","initialState","tokenData","undefined","balance","txBeingSent","transactionError","tokens","PUNK","MUNK","token","tokenAddress","MUNKAddress","Token","PUNKAddress","CustodianDApp","useState","state","setState","_provider","setProvider","new","input","setInput","custodians","setCustodians","transferState","setTransferState","_dismissNetworkError","useCallback","_initialize","userAddress","_custodians","getState","provider","ethers","providers","Web3Provider","window","ethereum","useEffect","setInterval","_updateBalance","_stopPollingData","console","log","clearInterval","a","MUNKToken","Contract","MUNKArtifact","abi","getSigner","PUNKToken","PUNKArtifact","Promise","all","balanceOf","munkCount","punkCount","custodian","contractAddress","CustodianArtifact","id","balances","getCustomerById","address","map","b","toString","find","t","saveState","_resetState","_checkNetwork","process","networkVersion","_connectWallet","request","method","on","newAddress","oldData","localStorage","getItem","parsedOldData","JSON","parse","setItem","stringify","data","parsedData","addCustodian","e","newCustodian","factory","ContractFactory","bytecode","deploy","contract","deployed","push","_state","cu","onInputChange","field","persist","onSelectToken","custodianWallet","importToken","onWithdraw","custodianContract","withdraw","setTransfer","fromToken","utils","formatEther","key","onChange","toAddress","tAddress","transfer","border","c","_c","setCustomerAddress","Number","vlaue","filtered","filter","colSpan","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"qthGAEO,SAASA,IACd,OACE,yBAAKC,UAAU,aACb,yBAAKA,UAAU,iCACb,yBAAKA,UAAU,yBACb,+DACmC,6BADnC,iBAEiB,IACf,uBACEC,KAAK,qBACLC,OAAO,SACPC,IAAI,uBAHN,YAHF,QCLH,SAASC,EAAT,GAAoD,IAArBC,EAAoB,EAApBA,QAASC,EAAW,EAAXA,QAC7C,OACE,yBAAKN,UAAU,qBAAqBO,KAAK,SACtCF,EACD,4BACEG,KAAK,SACLR,UAAU,QACVS,eAAa,QACbC,aAAW,QACXC,QAASL,GAET,0BAAMM,cAAY,QAAlB,UCTD,SAASC,EAAT,GAAkE,IAAzCC,EAAwC,EAAxCA,cAAeC,EAAyB,EAAzBA,aAAcT,EAAW,EAAXA,QAC3D,OACE,yBAAKN,UAAU,aACb,yBAAKA,UAAU,iCACb,yBAAKA,UAAU,sBAEZe,GACC,kBAACX,EAAD,CACEC,QAASU,EACTT,QAASA,KAIf,yBAAKN,UAAU,yBACb,6DACA,4BACEA,UAAU,kBACVQ,KAAK,SACLG,QAASG,GAHX,qBCjBH,SAASE,IACd,OACE,yBACEC,MAAO,CACLC,SAAU,QACVC,OAAQ,EACRC,IAAK,EACLC,KAAM,EACNC,MAAO,OACPC,OAAQ,OACRC,WAAY,6BAGd,yBACEP,MAAO,CACLC,SAAU,WACVC,OAAQ,EACRC,IAAK,MACLC,KAAM,MACNC,MAAO,QACPC,OAAQ,OACRE,WAAY,QACZC,UAAW,SACXC,UAAW,WAGb,yBAAK3B,UAAU,iBAAiBO,KAAK,UACnC,0BAAMP,UAAU,WAAhB,iBC3BH,SAAS4B,EAAT,GAAoD,IAAhCC,EAA+B,EAA/BA,eAAgBC,EAAe,EAAfA,YACzC,OACE,6BACE,wCACA,0BACEC,SAAU,SAACC,GAGTA,EAAMC,iBAEN,IAAMC,EAAW,IAAIC,SAASH,EAAM9B,QAC9BkC,EAAKF,EAASG,IAAI,MAClBC,EAASJ,EAASG,IAAI,UAExBD,GAAME,GACRT,EAAeO,EAAIE,KAIvB,yBAAKtC,UAAU,cACb,4CAAkB8B,GAClB,2BACE9B,UAAU,eACVQ,KAAK,SACL+B,KAAK,IACLC,KAAK,SACLC,YAAY,IACZC,UAAQ,KAGZ,yBAAK1C,UAAU,cACb,oDACA,2BAAOA,UAAU,eAAeQ,KAAK,OAAOgC,KAAK,KAAKE,UAAQ,KAEhE,yBAAK1C,UAAU,cACb,2BAAOA,UAAU,kBAAkBQ,KAAK,SAASmC,MAAM,gBCnC1D,SAASC,EAAT,GAAwD,IAArBvC,EAAoB,EAApBA,QAASC,EAAW,EAAXA,QACjD,OACE,yBAAKN,UAAU,qBAAqBO,KAAK,SAAzC,8BAC8BF,EAAQwC,UAAU,EAAG,KACjD,4BACErC,KAAK,SACLR,UAAU,QACVS,eAAa,QACbC,aAAW,QACXC,QAASL,GAET,0BAAMM,cAAY,QAAlB,UCXD,SAASkC,EAAT,GAAmD,IAAXC,EAAU,EAAVA,OAC7C,OACE,yBAAK/C,UAAU,mBAAmBO,KAAK,SAAvC,2BAC0B,gCAASwC,GADnC,gBCFG,SAASC,EAAT,GAA+C,IAApBC,EAAmB,EAAnBA,gBAChC,OACE,oCACE,gEACA,wGAEE,6BACA,6BACA,wEAA8CA,KC+B5BC,IAAMC,U,MAfhC,IC+BIC,E,wEAbEC,EAAe,CACnBC,eAAWC,EACXN,qBAAiBM,EACjBC,aAASD,EACTE,iBAAaF,EACbG,sBAAkBH,EAClBxC,kBAAcwC,EACdI,OAAO,GACPC,KAAK,EACLC,KAAK,GAGDF,EAAS,CAAC,CAACG,MAAM,OAAOC,aAAaC,EAAYC,OAAO,CAACH,MAAM,OAAOC,aAAaG,EAAYD,QAkYtFE,EA/XO,WACpB,MAA0BC,mBAASf,GAAnC,mBAAOgB,EAAP,KAAcC,EAAd,KACA,EAAiCF,mBAAS,MAA1C,mBAAOG,EAAP,KAAkBC,EAAlB,KACA,EAA0BJ,mBAAS,CAAEK,IAAK,KAA1C,mBAAOC,EAAP,KAAcC,EAAd,KACA,EAAoCP,mBAAS,IAA7C,mBAAOQ,EAAP,KAAmBC,EAAnB,KACA,EAA0CT,mBAAS,IAAnD,mBAAOU,EAAP,KAAsBC,EAAtB,KAEMC,EAAuBC,uBAAY,WACvCX,GAAS,SAACD,GAAD,mBAAC,eAAgBA,GAAjB,IAAwBtD,kBAAcwC,SAC9C,IAEG2B,EAAc,SAACC,GACnB,IAAMC,EAAcC,IACpBR,EAAcO,GAA4B,IAE1Cd,GAAS,SAACD,GAAD,mBAAC,eAAgBA,GAAjB,IAAwBpB,gBAAiBkC,OAElD,IAAMG,EAAW,IAAIC,IAAOC,UAAUC,aAAaC,OAAOC,UAC1DnB,EAAYc,IAgBdM,qBAAU,WACJrB,IAGJnB,EAAoByC,aAAY,WAC9BC,MACC,QACF,CAACvB,IAEJ,IAAMwB,EAAmB,WACvBC,QAAQC,IAAI,CAAC7C,sBACVA,GACD8C,cAAc9C,IAIZ0C,EAAc,uCAAG,oDAAAK,EAAA,6DACff,EAAcC,IAEde,EAAY,IAAIb,IAAOc,SAC3BrC,EAAYC,MACZqC,EAAaC,IACbhC,EAAUiC,UAAU,IAEhBC,EAAY,IAAIlB,IAAOc,SAC3BnC,EAAYD,MACZyC,EAAaH,IACbhC,EAAUiC,UAAU,IAXD,SAcgBG,QAAQC,IAAI,CAACR,EAAUS,UAAUxC,EAAMpB,iBAAiBwD,EAAUI,UAAUxC,EAAMpB,mBAdlG,mCAcd6D,EAdc,KAcHC,EAdG,KAerBzC,EAAS,2BACJD,GADG,IAENR,KAAKiD,EACLlD,KAAKmD,KAlBc,cAqBG3B,GArBH,+DAqBV4B,EArBU,SAsBJC,gBAtBI,+DA0BbhD,EAAQ,IAAIsB,IAAOc,SACvBW,EAAUC,gBACVC,EAAkBX,IAClBhC,EAAUiC,UAAU,IA7BH,UAiCIvC,EAAM4C,UAAUG,EAAUG,IAjC9B,eAiCbC,EAjCa,iBAkCGnD,EAAMoD,gBAAgBL,EAAUG,IAlCnC,QAkCbG,EAlCa,OAmCnBN,EAAUM,QAAUA,EAEpBN,EAAUI,SAAWA,EAASG,KAAI,SAAAC,GAAC,YAAK,CACtChE,QAASgE,EAAEhE,QAAQiE,WACnB3D,OAAO,UAAAH,EAAO+D,MAAK,SAAAC,GAAC,OAAIA,EAAE5D,cAAgByD,EAAEzD,uBAArC,eAAoDD,QAAS,OAGtEkC,QAAQC,IAAIe,EAAUI,UA1CH,iJA4CrBvC,EAAcO,GACdwC,EAAUxC,GA7CW,iEAAH,qDAgDdyC,EAAc,WAClBvD,EAASjB,GACTiB,EAAS,KAILwD,EAAgB7C,uBAAY,WAChC,MAAuC8C,MAAnCrC,OAAOC,SAASqC,iBAIpB1D,EAAS,2BACJD,GADG,IAENtD,aAAc,yCAGT,KACN,IAEGkH,EAAiBhD,sBAAW,sBAAC,gCAAAkB,EAAA,sEACDT,OAAOC,SAASuC,QAAQ,CACtDC,OAAQ,wBAFuB,sCAC1BlF,EAD0B,KAI5B6E,IAJ4B,iDAQjC5C,EAAYjC,GAEZyC,OAAOC,SAASyC,GAAG,mBAAmB,YAAmB,IAAjBC,EAAgB,oBAEtD,GADAtC,SACmBxC,IAAf8E,EACF,OAAOR,IAGT3C,EAAYmD,MAGd3C,OAAOC,SAASyC,GAAG,gBAAgB,YAAiB,oBAClDrC,IACA8B,IACAC,OAtB+B,4CAwBhC,IAEGF,EAAY,SAACxC,GACjB,IAAMkD,EAAU5C,OAAO6C,aAAaC,QAAQ,QACtCC,EAAgBH,EAAUI,KAAKC,MAAML,GAAW,GAEtD5C,OAAO6C,aAAaK,QAAQ,OAAQF,KAAKG,UAAL,2BAAmBJ,GAAnB,kBAAmCpE,EAAMpB,gBAAiB,CAAC2B,WAAWQ,QAEtGC,EAAW,WACf,IAAMyD,EAAOpD,OAAO6C,aAAaC,QAAQ,QAEnCO,GADSD,EAAOJ,KAAKC,MAAMG,GAAQ,IACfzE,EAAMpB,iBAChC,OAAiB,OAAV8F,QAAU,IAAVA,OAAA,EAAAA,EAAYnE,aAAc,IAG7BoE,EAAY,uCAAG,WAAOC,GAAP,2BAAA9C,EAAA,6DACb+C,EAAe,CACnB/B,GAAIzC,EAAMD,IAAI0C,GACdG,QAAS5C,EAAM4C,QACfL,gBAAiB,GACjBzD,QAAS,IAEL2F,EAAU,IAAIC,IAClBlC,EAAkBX,IAClBW,EAAkBmC,SAClB9E,EAAUiC,UAAU,IAVH,SAYI2C,EAAQG,OAC7BJ,EAAa/B,IAbI,cAYboC,EAZa,gBAebA,EAASC,WAfI,OAgBnBN,EAAajC,gBAAkBsC,EAASjC,QAExC1C,EAAW6E,KAAKP,GACVQ,EAAS,GAnBI,cAoBH9E,GApBG,IAoBnB,IAAI,EAAJ,qBAAU+E,EAAiB,QACzBD,EAAOC,EAAG1C,iBAAmB0C,EArBZ,8BAwBnBhF,EAAS,2BAAID,GAAUgF,IAEvB7E,EAAcD,GACdgD,EAAUhD,GA3BS,4CAAH,sDAwCZgF,EAAgB,SAACtC,EAAQuC,GAAT,OAAmB,SAACZ,GACxCA,EAAEa,UAEFnF,GAAS,SAACN,GAAD,mBAAC,eAAgBA,GAAjB,kBAAyBiD,EAAzB,YAAC,eAAqCjD,EAAMiD,IAA5C,kBAAuDuC,EAAQZ,EAAE/I,OAAOyC,eAE7EoH,EAAgB,SAAA/C,GAAS,8CAAI,WAAOiC,GAAP,eAAA9C,EAAA,yDAC7BzB,EAAMsC,EAAUC,iBAAiBnD,MADJ,wDAI3BkG,EAAkB,IAAIzE,IAAOc,SACjCW,EAAUC,gBACVC,EAAkBX,IAClBhC,EAAUiC,UAAU,IAPW,SAU3BwD,EAAgBC,YAAYjD,EAAUG,GAAIzC,EAAMsC,EAAUC,iBAAiBnD,OAVhD,2CAAJ,uDAuBzBoG,EAAa,SAAClD,GAAD,8CAAe,WAAMiC,GAAN,eAAA9C,EAAA,6DAC1BgE,EAAoB,IAAI5E,IAAOc,SACnCW,EAAUC,gBACVC,EAAkBX,IAClBhC,EAAUiC,UAAU,IAJU,SAO1B2D,EAAkBC,SAASpD,EAAUG,IAPX,2CAAf,uDAUbkD,GAAc,SAACC,EAAWT,GAAZ,OAAsB,SAAAZ,GACxClE,EAAiB,2BAAID,GAAL,kBAAqBwF,EAArB,YAAC,eAAmCxF,EAAcwF,IAAlD,kBAA+DT,EAAOZ,EAAE/I,OAAOyC,aAajG,YAAwBY,IAApBmC,OAAOC,SACF,kBAAC5F,EAAD,MAGJsE,EAAMpB,gBASN2B,EAKH,yBAAK5E,UAAU,iBACb,yBAAKA,UAAU,OACb,yBAAKA,UAAU,UACb,0DACA,2CACe,2BAAIqE,EAAMpB,iBADzB,aACuD,mCAASsC,IAAOgF,MAAMC,YAAYnG,EAAMR,OAD/F,IAC0G,mCAAS0B,IAAOgF,MAAMC,YAAYnG,EAAMT,QAEjJD,EAAO4D,KAAI,SAACI,EAAE8C,GAAH,OACV,uBAAGA,IAAKA,GACN,yBAAKzK,UAAU,OACb,2BACG2H,EAAE7D,MADL,KACc6D,EAAE5D,cAEhB,yBAAK/D,UAAU,SACf,2BAAOA,UAAU,eAAeyC,YAAY,cAAcE,MAAOmC,EAAcxC,OAAQ9B,KAAK,SAASkK,SAAUL,GAAY1C,EAAE5D,aAAc,YAD3I,KAEA,yBAAK/D,UAAU,SACf,2BAAOA,UAAU,eAAeyC,YAAY,kBAAkBE,MAAOmC,EAAc6F,UAAWD,SAAUL,GAAY1C,EAAE5D,aAAc,gBAEpI,yBAAK/D,UAAU,SACf,4BAAQA,UAAU,kBAAkBW,SA/CxBiK,EA+CmDjD,EAAE5D,aA/C7C,sBAAI,4BAAAoC,EAAA,6DAC9BrC,EAAQ,IAAIyB,IAAOc,SACvBuE,EACAtE,EAAaC,IACbhC,EAAUiC,UAAU,IAJc,SAO9B1C,EAAM+G,SAAS/F,EAAc8F,GAAUD,UAAW7F,EAAc8F,GAAUtI,QAP5C,6CA+CxB,WA/CY,IAAAsI,OAuDtB,6BAEA,yBAAK5K,UAAU,OACb,yBAAKA,UAAU,UACb,yBAAKA,UAAU,cACb,8CACe,IACb,2BACEQ,KAAK,OACLR,UAAU,eACV2C,MAAO+B,EAAMD,IAAI0C,GACjBuD,SAAUd,EAAc,MAAO,UAKrC,yBAAK5J,UAAU,cACb,4BAAQW,QAASqI,EAAchJ,UAAU,mBAAzC,aAON,yBAAKA,UAAU,OACb,yBAAKA,UAAU,UAAf,eAEA,2BAAOiB,MAAO,CAAEK,MAAO,QAAUwJ,OAAO,KACtC,+BACE,4BACE,kCACA,gDACA,gDACA,uCACA,4CACA,6BACA,+BAGJ,+BACGlG,EAAW2C,KAAI,SAACwD,EAAGN,GAAS,IAAD,IAnJdO,EA2BHhE,EAyHT,OACE,wBAAIyD,IAAKA,GACP,4BAAKM,EAAE5D,IACP,4BACE,yBAAKnH,UAAU,cACb,+BACE,2BACEQ,KAAK,OACLR,UAAU,eACV2C,MAAK,UAAE+B,EAAMqG,EAAE9D,wBAAV,aAAE,EAA0BK,QACjCoD,SAAUd,EAAcmB,EAAE9D,gBAAiB,aAE7C,8BAAO8D,EAAEzD,UAEX,4BAAQtH,UAAU,kBAAkBW,SAvInCqG,EAuIyD+D,EAvIhD,uCAAI,WAAO9B,GAAP,eAAA9C,EAAA,6DAChCH,QAAQC,IAAIe,GACNgD,EAAkB,IAAIzE,IAAOc,SACjCW,EAAUC,gBACVC,EAAkBX,IAClBhC,EAAUiC,UAAU,IALU,SAO1BwD,EAAgBiB,mBAAmBC,OAAOlE,EAAUG,IAAKzC,EAAMsC,EAAUC,iBAAiBK,SAPhE,2CAAJ,wDAuIV,iBAGJ,4BAAKyD,EAAE9D,iBACP,4BAAK8D,EAAE3D,UAAY2D,EAAE3D,SAASG,KAAI,SAACC,EAAEiD,GAAH,OAAW,0BAAMA,IAAKA,GAAMlF,IAAOgF,MAAMC,YAAYhD,EAAEhE,SAAS,2BAAIgE,EAAE1D,OAA3D,SAC7C,4BACE,4BAAQnB,MAAK,UAAE+B,EAAMqG,EAAE9D,wBAAV,aAAE,EAA0BnD,MAAO4G,SAAUd,EAAcmB,EAAE9D,gBAAiB,UACzF,4BAAQkE,MAAM,KACbxH,EAAO4D,KAAI,SAAAI,GAAC,OAAI,4BAAQhF,MAAOgF,EAAE5D,cAAe4D,EAAE7D,WAErD,4BAAQnD,QAASoJ,EAAcgB,GAAI/K,UAAU,gBAA7C,WAEF,4BACE,4BAAQA,UAAU,eAAeW,QAASuJ,EAAWa,IAArD,aAEF,4BACE,4BAAQ/K,UAAU,iBAAiBW,SAlL7BqK,EAkLsDD,EAlLhD,SAAC9B,GAC7B,IAAMmC,EAAWxG,EAAWyG,QAAO,SAAAN,GAAC,OAAIA,EAAE5D,KAAO6D,EAAG7D,MACpDzB,OAAO6C,aAAaK,QAAQ,OAAQF,KAAKG,UAAUuC,IACnDvG,EAAcuG,MA+KE,eAKR,4BACE,wBAAIE,QAAS,GACX,4BAAQtL,UAAU,iBAAiBW,QApL9B,SAACsI,GAClBpE,EAAc,IACdP,EAAS,MAkLG,eA7GL,kBAACtD,EAAD,MARL,kBAACH,EAAD,CACEC,cAAemH,EACflH,aAAcsD,EAAMtD,aACpBT,QAAS0E,KCjTjBuG,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAGFC,SAASC,eAAe,W","file":"static/js/main.c6d97fee.chunk.js","sourcesContent":["import React from \"react\";\n\nexport function NoWalletDetected() {\n  return (\n    <div className=\"container\">\n      <div className=\"row justify-content-md-center\">\n        <div className=\"col-6 p-4 text-center\">\n          <p>\n            No Ethereum wallet was detected. <br />\n            Please install{\" \"}\n            <a\n              href=\"http://metamask.io\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              MetaMask\n            </a>\n            .\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function NetworkErrorMessage({ message, dismiss }) {\n  return (\n    <div className=\"alert alert-danger\" role=\"alert\">\n      {message}\n      <button\n        type=\"button\"\n        className=\"close\"\n        data-dismiss=\"alert\"\n        aria-label=\"Close\"\n        onClick={dismiss}\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n  );\n}\n","import React from \"react\";\n\nimport { NetworkErrorMessage } from \"./NetworkErrorMessage\";\n\nexport function ConnectWallet({ connectWallet, networkError, dismiss }) {\n  return (\n    <div className=\"container\">\n      <div className=\"row justify-content-md-center\">\n        <div className=\"col-12 text-center\">\n          {/* Metamask network should be set to Localhost:8545. */}\n          {networkError && (\n            <NetworkErrorMessage \n              message={networkError} \n              dismiss={dismiss} \n            />\n          )}\n        </div>\n        <div className=\"col-6 p-4 text-center\">\n          <p>Please connect to your wallet.</p>\n          <button\n            className=\"btn btn-warning\"\n            type=\"button\"\n            onClick={connectWallet}\n          >\n            Connect Wallet\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function Loading() {\n  return (\n    <div\n      style={{\n        position: \"fixed\",\n        zIndex: 2,\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        background: \"rgba(255, 255, 255, 0.5)\",\n      }}\n    >\n      <div\n        style={{\n          position: \"absolute\",\n          zIndex: 3,\n          top: \"50%\",\n          left: \"50%\",\n          width: \"100px\",\n          height: \"50px\",\n          marginLeft: \"-50px\",\n          marginTop: \" -25px\",\n          textAlign: \"center\",\n        }}\n      >\n        <div className=\"spinner-border\" role=\"status\">\n          <span className=\"sr-only\">Loading...</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function Transfer({ transferTokens, tokenSymbol }) {\n  return (\n    <div>\n      <h4>Transfer</h4>\n      <form\n        onSubmit={(event) => {\n          // This function just calls the transferTokens callback with the\n          // form's data.\n          event.preventDefault();\n\n          const formData = new FormData(event.target);\n          const to = formData.get(\"to\");\n          const amount = formData.get(\"amount\");\n\n          if (to && amount) {\n            transferTokens(to, amount);\n          }\n        }}\n      >\n        <div className=\"form-group\">\n          <label>Amount of {tokenSymbol}</label>\n          <input\n            className=\"form-control\"\n            type=\"number\"\n            step=\"1\"\n            name=\"amount\"\n            placeholder=\"1\"\n            required\n          />\n        </div>\n        <div className=\"form-group\">\n          <label>Recipient address</label>\n          <input className=\"form-control\" type=\"text\" name=\"to\" required />\n        </div>\n        <div className=\"form-group\">\n          <input className=\"btn btn-primary\" type=\"submit\" value=\"Transfer\" />\n        </div>\n      </form>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function TransactionErrorMessage({ message, dismiss }) {\n  return (\n    <div className=\"alert alert-danger\" role=\"alert\">\n      Error sending transaction: {message.substring(0, 100)}\n      <button\n        type=\"button\"\n        className=\"close\"\n        data-dismiss=\"alert\"\n        aria-label=\"Close\"\n        onClick={dismiss}\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function WaitingForTransactionMessage({ txHash }) {\n  return (\n    <div className=\"alert alert-info\" role=\"alert\">\n      Waiting for transaction <strong>{txHash}</strong> to be mined\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function NoTokensMessage({ selectedAddress }) {\n  return (\n    <>\n      <p>You don't have tokens to transfer</p>\n      <p>\n        To get some tokens, open a terminal in the root of the repository and run: \n        <br />\n        <br />\n        <code>npx hardhat --network localhost faucet {selectedAddress}</code>\n      </p>\n    </>\n  );\n}\n","import React from \"react\";\n\n// We'll use ethers to interact with the Ethereum network and our contract\nimport { ethers } from \"ethers\";\n\n// We import the contract's artifacts and address here, as we are going to be\n// using them with ethers\nimport TokenArtifact from \"../contracts/Token.json\";\nimport contractAddress from \"../contracts/contract-address.json\";\n\n// All the logic of this dapp is contained in the Dapp component.\n// These other components are just presentational ones: they don't have any\n// logic. They just render HTML.\nimport { NoWalletDetected } from \"./NoWalletDetected\";\nimport { ConnectWallet } from \"./ConnectWallet\";\nimport { Loading } from \"./Loading\";\nimport { Transfer } from \"./Transfer\";\nimport { TransactionErrorMessage } from \"./TransactionErrorMessage\";\nimport { WaitingForTransactionMessage } from \"./WaitingForTransactionMessage\";\nimport { NoTokensMessage } from \"./NoTokensMessage\";\n\n// This is the Hardhat Network id, you might change it in the hardhat.config.js.\n// If you are using MetaMask, be sure to change the Network id to 1337.\n// Here's a list of network ids https://docs.metamask.io/guide/ethereum-provider.html#properties\n// to use when deploying to other networks.\n// const HARDHAT_NETWORK_ID = '1337';\nconst HARDHAT_NETWORK_ID = '31337';\n\n// This is an error code that indicates that the user canceled a transaction\nconst ERROR_CODE_TX_REJECTED_BY_USER = 4001;\n\n// This component is in charge of doing these things:\n//   1. It connects to the user's wallet\n//   2. Initializes ethers and the Token contract\n//   3. Polls the user balance to keep it updated.\n//   4. Transfers tokens by sending transactions\n//   5. Renders the whole application\n//\n// Note that (3) and (4) are specific of this sample application, but they show\n// you how to keep your Dapp and contract's state in sync,  and how to send a\n// transaction.\nexport class Dapp extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // We store multiple things in Dapp's state.\n    // You don't need to follow this pattern, but it's an useful example.\n    this.initialState = {\n      // The info of the token (i.e. It's Name and symbol)\n      tokenData: undefined,\n      // The user's address and balance\n      selectedAddress: undefined,\n      balance: undefined,\n      // The ID about transactions being sent, and any possible error with them\n      txBeingSent: undefined,\n      transactionError: undefined,\n      networkError: undefined,\n    };\n\n    this.state = this.initialState;\n  }\n\n  render() {\n    // Ethereum wallets inject the window.ethereum object. If it hasn't been\n    // injected, we instruct the user to install MetaMask.\n    if (window.ethereum === undefined) {\n      return <NoWalletDetected />;\n    }\n\n    // The next thing we need to do, is to ask the user to connect their wallet.\n    // When the wallet gets connected, we are going to save the users's address\n    // in the component's state. So, if it hasn't been saved yet, we have\n    // to show the ConnectWallet component.\n    //\n    // Note that we pass it a callback that is going to be called when the user\n    // clicks a button. This callback just calls the _connectWallet method.\n    if (!this.state.selectedAddress) {\n      return (\n        <ConnectWallet \n          connectWallet={() => this._connectWallet()} \n          networkError={this.state.networkError}\n          dismiss={() => this._dismissNetworkError()}\n        />\n      );\n    }\n\n    // If the token data or the user's balance hasn't loaded yet, we show\n    // a loading component.\n    if (!this.state.tokenData || !this.state.balance) {\n      return <Loading />;\n    }\n\n    // If everything is loaded, we render the application.\n    return (\n      <div className=\"container p-4\">\n        <div className=\"row\">\n          <div className=\"col-12\">\n            <h1>\n              {this.state.tokenData.name} ({this.state.tokenData.symbol})\n            </h1>\n            <p>\n              Welcome <b>{this.state.selectedAddress}</b>, you have{\" \"}\n              <b>\n                {this.state.balance.toString()} {this.state.tokenData.symbol}\n              </b>\n              .\n            </p>\n          </div>\n        </div>\n\n        <hr />\n\n        <div className=\"row\">\n          <div className=\"col-12\">\n            {/* \n              Sending a transaction isn't an immediate action. You have to wait\n              for it to be mined.\n              If we are waiting for one, we show a message here.\n            */}\n            {this.state.txBeingSent && (\n              <WaitingForTransactionMessage txHash={this.state.txBeingSent} />\n            )}\n\n            {/* \n              Sending a transaction can fail in multiple ways. \n              If that happened, we show a message here.\n            */}\n            {this.state.transactionError && (\n              <TransactionErrorMessage\n                message={this._getRpcErrorMessage(this.state.transactionError)}\n                dismiss={() => this._dismissTransactionError()}\n              />\n            )}\n          </div>\n        </div>\n\n        <div className=\"row\">\n          <div className=\"col-12\">\n            {/*\n              If the user has no tokens, we don't show the Transfer form\n            */}\n            {this.state.balance.eq(0) && (\n              <NoTokensMessage selectedAddress={this.state.selectedAddress} />\n            )}\n\n            {/*\n              This component displays a form that the user can use to send a \n              transaction and transfer some tokens.\n              The component doesn't have logic, it just calls the transferTokens\n              callback.\n            */}\n            {this.state.balance.gt(0) && (\n              <Transfer\n                transferTokens={(to, amount) =>\n                  this._transferTokens(to, amount)\n                }\n                tokenSymbol={this.state.tokenData.symbol}\n              />\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  componentWillUnmount() {\n    // We poll the user's balance, so we have to stop doing that when Dapp\n    // gets unmounted\n    this._stopPollingData();\n  }\n\n  async _connectWallet() {\n    // This method is run when the user clicks the Connect. It connects the\n    // dapp to the user's wallet, and initializes it.\n\n    // To connect to the user's wallet, we have to run this method.\n    // It returns a promise that will resolve to the user's address.\n    const [selectedAddress] = await window.ethereum.request({ method: 'eth_requestAccounts' });\n\n    // Once we have the address, we can initialize the application.\n\n    // First we check the network\n    if (!this._checkNetwork()) {\n      return;\n    }\n\n    this._initialize(selectedAddress);\n\n    // We reinitialize it whenever the user changes their account.\n    window.ethereum.on(\"accountsChanged\", ([newAddress]) => {\n      this._stopPollingData();\n      // `accountsChanged` event can be triggered with an undefined newAddress.\n      // This happens when the user removes the Dapp from the \"Connected\n      // list of sites allowed access to your addresses\" (Metamask > Settings > Connections)\n      // To avoid errors, we reset the dapp state \n      if (newAddress === undefined) {\n        return this._resetState();\n      }\n      \n      this._initialize(newAddress);\n    });\n    \n    // We reset the dapp state if the network is changed\n    window.ethereum.on(\"chainChanged\", ([networkId]) => {\n      this._stopPollingData();\n      this._resetState();\n    });\n  }\n\n  _initialize(userAddress) {\n    // This method initializes the dapp\n\n    // We first store the user's address in the component's state\n    this.setState({\n      selectedAddress: userAddress,\n    });\n\n    // Then, we initialize ethers, fetch the token's data, and start polling\n    // for the user's balance.\n\n    // Fetching the token data and the user's balance are specific to this\n    // sample project, but you can reuse the same initialization pattern.\n    this._initializeEthers();\n    this._getTokenData();\n    this._startPollingData();\n  }\n\n  async _initializeEthers() {\n    // We first initialize ethers by creating a provider using window.ethereum\n    this._provider = new ethers.providers.Web3Provider(window.ethereum);\n\n    // Then, we initialize the contract using that provider and the token's\n    // artifact. You can do this same thing with your contracts.\n    this._token = new ethers.Contract(\n      contractAddress.Token,\n      TokenArtifact.abi,\n      this._provider.getSigner(0)\n    );\n  }\n\n  // The next two methods are needed to start and stop polling data. While\n  // the data being polled here is specific to this example, you can use this\n  // pattern to read any data from your contracts.\n  //\n  // Note that if you don't need it to update in near real time, you probably\n  // don't need to poll it. If that's the case, you can just fetch it when you\n  // initialize the app, as we do with the token data.\n  _startPollingData() {\n    this._pollDataInterval = setInterval(() => this._updateBalance(), 1000);\n\n    // We run it once immediately so we don't have to wait for it\n    this._updateBalance();\n  }\n\n  _stopPollingData() {\n    clearInterval(this._pollDataInterval);\n    this._pollDataInterval = undefined;\n  }\n\n  // The next two methods just read from the contract and store the results\n  // in the component state.\n  async _getTokenData() {\n    const name = await this._token.name();\n    const symbol = await this._token.symbol();\n\n    this.setState({ tokenData: { name, symbol } });\n  }\n\n  async _updateBalance() {\n    const balance = await this._token.balanceOf(this.state.selectedAddress);\n    this.setState({ balance });\n  }\n\n  // This method sends an ethereum transaction to transfer tokens.\n  // While this action is specific to this application, it illustrates how to\n  // send a transaction.\n  async _transferTokens(to, amount) {\n    // Sending a transaction is a complex operation:\n    //   - The user can reject it\n    //   - It can fail before reaching the ethereum network (i.e. if the user\n    //     doesn't have ETH for paying for the tx's gas)\n    //   - It has to be mined, so it isn't immediately confirmed.\n    //     Note that some testing networks, like Hardhat Network, do mine\n    //     transactions immediately, but your dapp should be prepared for\n    //     other networks.\n    //   - It can fail once mined.\n    //\n    // This method handles all of those things, so keep reading to learn how to\n    // do it.\n\n    try {\n      // If a transaction fails, we save that error in the component's state.\n      // We only save one such error, so before sending a second transaction, we\n      // clear it.\n      this._dismissTransactionError();\n\n      // We send the transaction, and save its hash in the Dapp's state. This\n      // way we can indicate that we are waiting for it to be mined.\n      const tx = await this._token.transfer(to, amount);\n      this.setState({ txBeingSent: tx.hash });\n\n      // We use .wait() to wait for the transaction to be mined. This method\n      // returns the transaction's receipt.\n      const receipt = await tx.wait();\n\n      // The receipt, contains a status flag, which is 0 to indicate an error.\n      if (receipt.status === 0) {\n        // We can't know the exact error that made the transaction fail when it\n        // was mined, so we throw this generic one.\n        throw new Error(\"Transaction failed\");\n      }\n\n      // If we got here, the transaction was successful, so you may want to\n      // update your state. Here, we update the user's balance.\n      await this._updateBalance();\n    } catch (error) {\n      // We check the error code to see if this error was produced because the\n      // user rejected a tx. If that's the case, we do nothing.\n      if (error.code === ERROR_CODE_TX_REJECTED_BY_USER) {\n        return;\n      }\n\n      // Other errors are logged and stored in the Dapp's state. This is used to\n      // show them to the user, and for debugging.\n      console.error(error);\n      this.setState({ transactionError: error });\n    } finally {\n      // If we leave the try/catch, we aren't sending a tx anymore, so we clear\n      // this part of the state.\n      this.setState({ txBeingSent: undefined });\n    }\n  }\n\n  // This method just clears part of the state.\n  _dismissTransactionError() {\n    this.setState({ transactionError: undefined });\n  }\n\n  // This method just clears part of the state.\n  _dismissNetworkError() {\n    this.setState({ networkError: undefined });\n  }\n\n  // This is an utility method that turns an RPC error into a human readable\n  // message.\n  _getRpcErrorMessage(error) {\n    if (error.data) {\n      return error.data.message;\n    }\n\n    return error.message;\n  }\n\n  // This method resets the state\n  _resetState() {\n    this.setState(this.initialState);\n  }\n\n  // This method checks if Metamask selected network is Localhost:8545 \n  _checkNetwork() {\n    if (window.ethereum.networkVersion === HARDHAT_NETWORK_ID) {\n      return true;\n    }\n\n    this.setState({ \n      networkError: 'Please connect Metamask to Localhost:8545'\n    });\n\n    return false;\n  }\n}\n","import React, { useCallback, useEffect, useState } from \"react\";\n\n// We'll use ethers to interact with the Ethereum network and our contract\nimport { ethers, ContractFactory } from \"ethers\";\n\n// We import the contract's artifacts and address here, as we are going to be\n// using them with ethers\nimport MUNKArtifact from \"../contracts/MUNK.json\";\nimport PUNKArtifact from \"../contracts/PUNK.json\";\nimport MUNKAddress from \"../contracts/MUNK-address.json\";\nimport PUNKAddress from \"../contracts/PUNK-address.json\";\nimport CustodianArtifact from \"../contracts/CustodianSC.json\";\n\n// All the logic of this dapp is contained in the Dapp component.\n// These other components are just presentational ones: they don't have any\n// logic. They just render HTML.\nimport { NoWalletDetected } from \"./NoWalletDetected\";\nimport { ConnectWallet } from \"./ConnectWallet\";\nimport { Loading } from \"./Loading\";\nimport { Transfer } from \"./Transfer\";\nimport { TransactionErrorMessage } from \"./TransactionErrorMessage\";\nimport { WaitingForTransactionMessage } from \"./WaitingForTransactionMessage\";\nimport { NoTokensMessage } from \"./NoTokensMessage\";\n\n// This is the Hardhat Network id, you might change it in the hardhat.config.js.\n// If you are using MetaMask, be sure to change the Network id to 1337.\n// Here's a list of network ids https://docs.metamask.io/guide/ethereum-provider.html#properties\n// to use when deploying to other networks.\n// const HARDHAT_NETWORK_ID = '1337';\nconst HARDHAT_NETWORK_ID = \"31337\";\n\n// This is an error code that indicates that the user canceled a transaction\nconst ERROR_CODE_TX_REJECTED_BY_USER = 4001;\n\n// This component is in charge of doing these things:\n//   1. It connects to the user's wallet\n//   2. Initializes ethers and the Token contract\n//   3. Polls the user balance to keep it updated.\n//   4. Transfers tokens by sending transactions\n//   5. Renders the whole application\n//\n// Note that (3) and (4) are specific of this sample application, but they show\n// you how to keep your Dapp and contract's state in sync,  and how to send a\n// transaction.\nconst initialState = {\n  tokenData: undefined,\n  selectedAddress: undefined,\n  balance: undefined,\n  txBeingSent: undefined,\n  transactionError: undefined,\n  networkError: undefined,\n  tokens:[],\n  PUNK:0,\n  MUNK:0,\n};\n\nconst tokens = [{token:'MUNK',tokenAddress:MUNKAddress.Token},{token:'PUNK',tokenAddress:PUNKAddress.Token}]\nlet _pollDataInterval\n\nconst CustodianDApp = () => {\n  const [state, setState] = useState(initialState);\n  const [_provider, setProvider] = useState(null);\n  const [input, setInput] = useState({ new: {} });\n  const [custodians, setCustodians] = useState([]);\n  const [transferState, setTransferState] = useState({});\n\n  const _dismissNetworkError = useCallback(() => {\n    setState((state) => ({ ...state, networkError: undefined }));\n  }, []);\n\n  const _initialize = (userAddress) => {\n    const _custodians = getState()\n    setCustodians(_custodians ? _custodians : []);\n\n    setState((state) => ({ ...state, selectedAddress: userAddress }));\n\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    setProvider(provider);\n\n    // // Then, we initialize the contract using that provider and the token's\n    // // artifact. You can do this same thing with your contracts.\n    // const MUNKToken = new ethers.Contract(\n    //   MUNKAddress.Token,\n    //   MUNKArtifact.abi,\n    //   provider.getSigner(0)\n    // );\n    // const PUNKToken = new ethers.Contract(\n    //   PUNKAddress.Token,\n    //   PUNKArtifact.abi,\n    //   provider.getSigner(0)\n    // );\n  };\n\n  useEffect(() => {\n    if(!_provider){\n      return\n    }\n    _pollDataInterval = setInterval(() => {\n      _updateBalance();\n    }, 1000)\n  }, [_provider]);\n\n  const _stopPollingData = () => {\n    console.log({_pollDataInterval})\n    if(_pollDataInterval){\n      clearInterval(_pollDataInterval);\n    }\n  };\n\n  const _updateBalance = async () => {\n    const _custodians = getState()\n\n    const MUNKToken = new ethers.Contract(\n      MUNKAddress.Token,\n      MUNKArtifact.abi,\n      _provider.getSigner(0)\n    )\n    const PUNKToken = new ethers.Contract(\n      PUNKAddress.Token,\n      PUNKArtifact.abi,\n      _provider.getSigner(0)\n    )\n\n    const [munkCount, punkCount] = await Promise.all([MUNKToken.balanceOf(state.selectedAddress),PUNKToken.balanceOf(state.selectedAddress)])\n    setState({\n      ...state,\n      MUNK:munkCount,\n      PUNK:punkCount\n    })\n\n    for (const custodian of _custodians) {\n      if (!custodian.contractAddress) {\n        continue;\n      }\n\n      const Token = new ethers.Contract(\n        custodian.contractAddress,\n        CustodianArtifact.abi,\n        _provider.getSigner(0)\n      )\n\n      // await Token.importToken(custodian.id, state.tokens[0].address);\n      const balances = await Token.balanceOf(custodian.id);\n      const address = await Token.getCustomerById(custodian.id);\n      custodian.address = address\n      \n      custodian.balances = balances.map(b => ({\n        balance: b.balance.toString(),\n        token: tokens.find(t => t.tokenAddress == b.tokenAddress)?.token || ''\n      }))\n\n      console.log(custodian.balances)\n    }\n    setCustodians(_custodians);\n    saveState(_custodians)\n  }\n\n  const _resetState = () => {\n    setState(initialState);\n    setState([])\n  };\n\n  // This method checks if Metamask selected network is Localhost:8545\n  const _checkNetwork = useCallback(() => {\n    if (window.ethereum.networkVersion === process.env.REACT_APP_HARDHAT_NETWORK_ID) {\n      return true;\n    }\n\n    setState({\n      ...state,\n      networkError: \"Please connect Metamask to Ropsten\",\n    });\n\n    return false;\n  }, []);\n\n  const _connectWallet = useCallback(async () => {\n    const [selectedAddress] = await window.ethereum.request({\n      method: \"eth_requestAccounts\",\n    });\n    if (!_checkNetwork()) {\n      return;\n    }\n\n    _initialize(selectedAddress);\n\n    window.ethereum.on(\"accountsChanged\", ([newAddress]) => {\n      _stopPollingData();\n      if (newAddress === undefined) {\n        return _resetState();\n      }\n\n      _initialize(newAddress);\n    });\n\n    window.ethereum.on(\"chainChanged\", ([networkId]) => {\n      _stopPollingData();\n      _resetState();\n      _checkNetwork()\n    });\n  }, []);\n\n  const saveState = (_custodians) => {\n    const oldData = window.localStorage.getItem(\"data\");\n    const parsedOldData = oldData ? JSON.parse(oldData) : {}\n\n    window.localStorage.setItem(\"data\", JSON.stringify({...parsedOldData, [state.selectedAddress]:{custodians:_custodians}}));\n  }\n  const getState = () => {\n    const data = window.localStorage.getItem(\"data\");\n    const _state = data ? JSON.parse(data) : {}\n    const parsedData = _state[state.selectedAddress]\n    return parsedData?.custodians || []\n  }\n\n  const addCustodian = async (e) => {\n    const newCustodian = {\n      id: input.new.id,\n      address: input.address,\n      contractAddress: \"\",\n      balance: [],\n    };\n    const factory = new ContractFactory(\n      CustodianArtifact.abi,\n      CustodianArtifact.bytecode,\n      _provider.getSigner(0)\n    );\n    const contract = await factory.deploy(\n      newCustodian.id\n    );\n    await contract.deployed();\n    newCustodian.contractAddress = contract.address;\n\n    custodians.push(newCustodian);\n    const _state = {}\n    for(const cu of custodians){\n      _state[cu.contractAddress] = cu\n    }\n\n    setInput({...input, ..._state})\n\n    setCustodians(custodians);\n    saveState(custodians)\n    \n  };\n  const deleteCustodian = _c => (e) => {\n    const filtered = custodians.filter(c => c.id !== _c.id)\n    window.localStorage.setItem(\"data\", JSON.stringify(filtered));\n    setCustodians(filtered)\n  }\n  const resetTable = (e) => {\n    setCustodians([]);\n    setState([])\n  };\n\n  const onInputChange = (address,field) => (e) => {\n    e.persist();\n\n    setInput((state) => ({ ...state, [address]:{...state[address], [field]: e.target.value} }));\n  };\n  const onSelectToken = custodian => async (e) => {\n    if(!input[custodian.contractAddress].token){\n      return\n    }\n    const custodianWallet = new ethers.Contract(\n      custodian.contractAddress,\n      CustodianArtifact.abi,\n      _provider.getSigner(0)\n    );\n\n    await custodianWallet.importToken(custodian.id, input[custodian.contractAddress].token)\n  };\n  const onSetAddress = custodian => async (e) => {\n    console.log(custodian)\n    const custodianWallet = new ethers.Contract(\n      custodian.contractAddress,\n      CustodianArtifact.abi,\n      _provider.getSigner(0)\n    );\n    await custodianWallet.setCustomerAddress(Number(custodian.id), input[custodian.contractAddress].address)\n  };\n\n\n  const onWithdraw = (custodian) => async e => {\n    const custodianContract = new ethers.Contract(\n      custodian.contractAddress,\n      CustodianArtifact.abi,\n      _provider.getSigner(0)\n    )\n\n    await custodianContract.withdraw(custodian.id)\n  }\n\n  const setTransfer = (fromToken, field) => e => {\n    setTransferState({...transferState, [fromToken]:{...transferState[fromToken], [field]:e.target.value}})\n  }\n\n  const onSendTransaction = tAddress => async () => {\n    const token = new ethers.Contract(\n      tAddress,\n      MUNKArtifact.abi,\n      _provider.getSigner(0)\n    )\n\n    await token.transfer(transferState[tAddress].toAddress, transferState[tAddress].amount)\n  }\n\n  if (window.ethereum === undefined) {\n    return <NoWalletDetected />;\n  }\n\n  if (!state.selectedAddress) {\n    return (\n      <ConnectWallet\n        connectWallet={_connectWallet}\n        networkError={state.networkError}\n        dismiss={_dismissNetworkError}\n      />\n    );\n  }\n  if (!custodians) {\n    return <Loading />;\n  }\n\n  return (\n    <div className=\"container p-4\">\n      <div className=\"row\">\n        <div className=\"col-12\">\n          <h1>Custodian wallet Demo Page</h1>\n          <p>\n            connected as <b>{state.selectedAddress}</b> Balance: <b>MUNK:{ethers.utils.formatEther(state.MUNK)}</b> <b>PUNK:{ethers.utils.formatEther(state.PUNK)}</b>\n          </p>\n          {tokens.map((t,key) => (\n            <p key={key}>\n              <div className=\"row\">\n                <b>\n                  {t.token}: {t.tokenAddress}\n                </b>\n                <div className=\"col-2\">\n                <input className=\"form-control\" placeholder=\"Send amount\" value={transferState.amount} type=\"number\" onChange={setTransfer(t.tokenAddress, 'amount')} /> </div>\n                <div className=\"col-2\">\n                <input className=\"form-control\" placeholder=\"Send to address\" value={transferState.toAddress} onChange={setTransfer(t.tokenAddress, 'toAddress')} />\n                </div>\n                <div className=\"col-2\">\n                <button className=\"btn btn-primary\" onClick={onSendTransaction(t.tokenAddress)}>Send</button>\n                </div>\n              </div>\n            </p>\n          ))}\n        </div>\n      </div>\n\n      <hr />\n\n      <div className=\"row\">\n        <div className=\"col-12\">\n          <div className=\"form-group\">\n            <label>\n              Customer id:{\" \"}\n              <input\n                type=\"text\"\n                className=\"form-control\"\n                value={input.new.id}\n                onChange={onInputChange('new', \"id\")}\n              />\n            </label>\n          </div>\n          \n          <div className=\"form-group\">\n            <button onClick={addCustodian} className=\"btn btn-primary\">\n              Create\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"row\">\n        <div className=\"col-12\">Custodians:</div>\n\n        <table style={{ width: \"100%\" }} border=\"1\">\n          <thead>\n            <tr>\n              <th>id</th>\n              <th>customer address</th>\n              <th>contract address</th>\n              <th>balance</th>\n              <th>import token</th>\n              <th></th>\n              <th></th>\n            </tr>\n          </thead>\n          <tbody>\n            {custodians.map((c, key) => {\n              return (\n                <tr key={key}>\n                  <td>{c.id}</td>\n                  <td>\n                    <div className=\"form-group\">\n                      <label>\n                        <input\n                          type=\"text\"\n                          className=\"form-control\"\n                          value={input[c.contractAddress]?.address}\n                          onChange={onInputChange(c.contractAddress, \"address\")}\n                        />\n                        <span>{c.address}</span>\n                      </label>\n                      <button className=\"btn btn-primary\" onClick={onSetAddress(c)}>Set address</button>\n                    </div>  \n                  </td>\n                  <td>{c.contractAddress}</td>\n                  <td>{c.balances && c.balances.map((b,key) => <span key={key}>{ethers.utils.formatEther(b.balance)}<b>{b.token}</b>,</span>)}</td>\n                  <td>\n                    <select value={input[c.contractAddress]?.token} onChange={onInputChange(c.contractAddress, \"token\")}>\n                      <option vlaue=\"\"></option>\n                      {tokens.map(t => <option value={t.tokenAddress}>{t.token}</option>)}\n                    </select>\n                    <button onClick={onSelectToken(c)} className=\"btn btn-info\">Import</button>\n                  </td>\n                  <td>\n                    <button className=\"btn btn-info\" onClick={onWithdraw(c)}>Withdraw</button>\n                  </td>\n                  <td>\n                    <button className=\"btn btn-danger\" onClick={deleteCustodian(c)}>Delete</button>\n                  </td>\n                </tr>\n              );\n            })}\n            <tr>\n              <td colSpan={6}>\n                <button className=\"btn btn-danger\" onClick={resetTable}>\n                  Reset\n                </button>\n              </td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n};\n\nexport default CustodianDApp;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Dapp } from \"./components/Dapp\";\n\n// We import bootstrap here, but you can remove if you want\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport CustodianDApp from \"./components/CustodianDApp\";\n\n// This is the entry point of your application, but it just renders the Dapp\n// react component. All of the logic is contained in it.\n\nReactDOM.render(\n  <React.StrictMode>\n    <CustodianDApp />\n    {/* <Dapp /> */}\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}